# 渲染页面过程

- 渲染器进程：核心任务就是把 `html`、`css`、`js`、`image` 等渲染成用户可交互的web页面
- 主线程：DOM => style => layout（布局） => paint（绘制） => layer（图层）
- 合成器线程：图层切分快 和 合成器帧发送
- 栅格线程：图块栅格化，图块的信息


## 渲染页面

1. 解析 html（DOM Tree）`主线程`
   1. 解析 html 异步解析
   2. 通过词法分析，将 `html` 解析多个标记
   3. 根据标记，进行 `DOM Tree` 构造 
   4. 构造过程中创建 `document` 对象
   5. 以 `document` 为根节点 `DOM Tree`，不断进行修改，向其中添加各种元素，创建 `DOM Tree`
   
2. 解析 css （style Tree）`主线程`
   1. 解析 css，并确定 DOM 节点的计算样式
   2. 如果没有就用浏览器默认的 css
   3. 生成 `style Tree`
   4. 如果 link 会将引入的css 全部解析完成 同步解析

3. 创建 layout 布局 （layout Tree）`主线程`
   1. 主线程根据 DOM Tree 和 style Tree 来创建 layout Tree
   2. layout Tree 每个节点会记录 x y 坐标和边框大小等
   3. DOM Tree 和 layout Tree 不是一一对应的
      1. DOM Tree 设置了 display：none 的，layout 不会显示
      2. 在 css 伪类中添加了 content 内容的元素，content的内容 不会出现在 DOM Tree 上
      3. 伪类 是通过 css 解析的不会出现在的 dom 上

4. 创建绘制表（paint）`主线程`
   1. 根据 layout 创建绘制记录表
   2. 确定绘制顺序，z-inde 这些
   
5. 生成 layer Tree（图层）`主线程` 
   1. 根据 layout Tree 生成 layer Tree（图层）
   2. 并把 layout Tree 和 layer Tree 传递给合成器线程（通过IPC传递）
   
6. 分图层和切块 `合成器线程` 
   1. 合成器线程将图层切分为图块
   2. 将图块发送诶栅格线程
   
7. 栅格化  `栅格线程`
   1. 对图块进行栅格化，
   2. 产生图块信息
   3. 并把图块信息传递给合成器
   
8. 渲染
   1. 合成器进程收到栅格线程的图块信息，
   2. 根据信息合成器线程合成一个合成器帧
   3. 通过 IPC 将合成器帧 传递得浏览器进程
   4. 浏览器进程再传到 CPU 进行渲染


## 重排和重绘问题

- 重排：当修改元素尺寸和位置时，会触发样式计算（style）、布局（layout）、绘制（paint）以及后面所有流程
- 重绘：当修改元素的颜色时，会触发样式计算（style）以及绘制（paint）

反复做的重排和重绘会导致掉帧卡顿，重排和重绘都会占用主线程，JS会执行会阻塞主线程

### 重排
<img src="./img2.png" width="800"/>

### 重绘
<img src="./img.png" width="800"/>

## 优化
### requestAnimationFrame()

> window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，
> 并且要求浏览器在 **下次重绘之前调用** 指定的回调函数更新动画。
> 该方法需要传入一个回调函数作为参数，该回调函数会在浏览器 **下一次重绘之前** 执行

- 方法在**每一帧之前调**用告诉浏览器——你希望执行一个动画，并且要求浏览器在下次**重绘之前**调用指定的回调函数更新动画
- 把 js 任务 分成更小的任务块
- 在每一帧完成前暂停js 执行归还主线程
- 下一帧开始时主线程就可以按时执行布局和绘制
- react 最新的渲染引擎，react Filer用这个api 做了很多优化
- 中断（Generator）和 异步的思想

### transform

- 该属性实现动画不会经过布局和绘制（不会占用主线程）
- 会运行在 `合成器线程` 和 `栅格线程` 中，不受主线程的js执行的影响
- transform 实现动画不需要经过布局（layout）、绘制（paint）样式计算等操作节省了运算时间

## 阻塞渲染的
- css 阻塞 
  1. style标签： 
     - 由 html 解析器解析（异步）
     - 边加载边渲染
     - 不阻塞浏览器渲染
     - 不阻塞 DOM 解析
     - 异步解析的，分组解析渲染，容易出现闪屏现象
  2. link 引入css：（推荐使用） 
     - 由 css 解析器进行解析 (同步)
     - 解析完成后
     - 不阻塞 DOM 解析
     - 阻塞浏览器渲染
     - 阻塞 script 标签中 js 执行
     - 解析 css 样式，只解析一次，是同步的，等所有的 css 全部加载完再解析
  3. style：内联 
     1. 一进页面，就看见了盒子，这个盒子背景颜色 赤橙红绿青蓝紫 闪一遍，最终颜色是紫色 （过程都看出来）
  4. link：外链 
     1. 进页面先空白，因为这个时候在请求资源、解析，等着 Stylesheet 解析完了，统一渲染，盒子出来，背景颜色是紫色
- JS 阻塞
  1. 阻塞后续DOM解析 
  2. 阻塞渲染 
  3. 阻塞后续JS执行
  4. 图片需要通过网络下载或从缓存中直接加载不会阻塞 html 解析，因为他们不会影响 dom 的生成

## 阻塞优化
- css 优化：
  1. 首屏页面 css 独立出来，放到 style 里面內联加载，加载html的时候同时加载 
  2. 使用 cdn 节点进行外部资源加速 
  3. 对 css 进行压缩，比如使用（webpack、gulp等） 
  4. 减少 http 资源请求次数，多个 css 文件合并
  5. 优化样式表的代码
  6. [style 样式渲染](https://blog.csdn.net/Luckyzhoufangbing/article/details/108548783)

- JS 优化：在页面的最下面引入 js，或者使用 defer 属性，这样页面在渲染会在渲染完成后加载 
  - async：异步加载，下载过程中不会影响到 html 的解析，但是下载完成后会立即执行，对堵塞 html 解析 
  - defer：异步加载，下载过程中不会影响到 html 的解析，会在所有的元素解析完成后，DOMContentLoaded 事件之前触发完成



- 参考
- [浏览器渲染机制](https://segmentfault.com/a/1190000022084293)
