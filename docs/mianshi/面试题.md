# 常见面试题


## JavaScript

### common.js 和 es6 中模块引入的区别？

commonJs： `require` / `exports` 是一种模块语法，最初应用用 `nodejs` 成为 `nodejs` 的模块规范

ES6 模块：
`import` / `export` 

- `commonJs` 模块是输出的是一个值的拷贝，ES6 模块输出的是值的引用
- `commonJs` 模块是运行是加载，ES6 模块是编译时输出接口
- `commonJs` 是单个值导出，ES6 模块可以导出多个
- `commonJs` 是动态语法可以写判断，ES6 模块静态语法只能写在顶层（如果要写在别的地方，可以使用 `import()` 函数实现）
    - `require('url' + a + b)` 不会报错
    - `import 'url' + a + b `会报错，可以使用 `import('url' + a + b)`
- `commonJs` 的 `this` 是当前的模块，ES6 模块的 `this` 是 `undefined`

## 框架相关的

### 计算属性 VS 侦听属性


### Virtual（虚拟） Dom 的优势在哪里？

首先：
- dom 引擎、js 引擎是相互独立的，但又在同一个线程里面（主线程）
- js 代码调用 dom API 必须挂起 js 引擎，
- 传入参数数据等、然后 dom 引擎激活，DOM 重绘后可能与返回值
- 然后在激活 JS 引擎并继续执行类似频繁的 DOM API调用
- 且浏览器厂商做批量优化处理
- 引擎之前的频繁切换，若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会增加更大的性能消耗


其次是 VDOM 和真实 DOM 的区别和优化：

1. 虚拟 DOM 不会立马进行排版和重绘操作

2. 虚拟 DOM 进行频繁修改后，然后一次性的比较并修改 DOM 中需要改的部分，
最后在真实 DOM 中进行排版与重绘，减少过多的 DOM 节点排版和重绘消耗

3. 虚拟 DOM 有效的降低大面积真实 DOM 的重绘和排版，因为最后与真实 DOM 比较差异，可以只渲染局部


## http 网络相关的

### tcp 的三次握手

#### 三次过程：

- 客户端：你能收我消息么？
- 服务端：可以的，你能接收到我的回复吗？
- 客户端：可以的，那我们开始聊正事把

1. 为啥是3次：
   - 三次是最少的安全次数，两次不安全，四次浪费资源。
   - 避免历史链接，确定客户端发的请求是这次通讯的人

2. 为啥不是4次：
   - 四次浪费资源

### tcp 协议 四次挥手

#### 四次挥手过程：

TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道：

- 通道1：客户端的输出链接服务端的输入
  
- 通道2：客户端的输入链接服务端的输出

两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。


关闭通道：

- 客户端：我要关闭通道了
  
- 服务端：好的你关闭，我这边也要关闭通道了
    
- 服务端：我也要关闭通道了
  
- 客户端：好的，你关闭吧，我也吧这个通道关闭了


1. 为什么不能是两次
    - 无法确认服务端是否能到断开消息，还有服务端可能还有消息未发送完

2. 为什么不能是三次
    - 三次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。


<img src="./img/img4.png" width="600"> 


### 一个 tcp 连接能发几个 http 请求

