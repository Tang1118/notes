# 常见面试题

## JavaScript

### common.js 和 es6 中模块引入的区别？

commonJs： `require` / `exports` 是一种模块语法，最初应用用 `nodejs` 成为 `nodejs` 的模块规范

ES6 模块：
`import` / `export` 

- `commonJs` 模块是输出的是一个值的拷贝，ES6 模块输出的是值的引用
- `commonJs` 模块是运行是加载，是`同步`加载的，ES6 模块是编译时输出接口
- `commonJs` 是单个值导出，ES6 模块可以导出多个
- `commonJs` 是动态语法可以写判断，ES6 模块静态语法只能写在顶层（如果要写在别的地方，可以使用 `import()` 函数实现）
    - `require('url' + a + b)` 不会报错
    - `import 'url' + a + b `会报错，可以使用 `import('url' + a + b)`
- `commonJs` 的 `this` 是当前的模块，ES6 模块的 `this` 是 `undefined`

## 框架相关的

### vue 初次渲染过程

`new vue` => `init` => `$mount` => `compile(编译)` => `render` => `vnode` => `patch` => `dom`


### vue template 怎么理解

vue 的模版语法，是一种描述视图的标记语言，通过 vue 的 vue-template-compiler 解析成 render 函数，
再通过 vnode 加上 diff 算法统一替换 dom 形成证实的视图，所以 vue 和 react 在本质上类似。
也就是说 vue 也可以和 react 一样通过 jsx 来描绘视图，不同的是 vue 提高了一套更符合前端思维的标记语言

生成jsx的语法糖，主要是用来生成描述页面的对象

### vue 的 计算属性 VS 监听属性

#### 计算属性
- 计算属性被访问的时触发 getter 函数，执行用户返回的计算结果，
如果返回值发生来变化才触发更新（有缓存，依赖发生变化才执行）

- 依赖属性更新：计算属性会成为，依赖属性的订阅者，依赖变量发生变化改变则触发计算属性重新计算

- 计算属性有 lazy 和 active两种模式，active模式依赖更新立即计算，lazy模式依赖变化仅设置this.dirty = true，等访问计算属性时再重新计算，并加入缓存。


#### 监听属性
- 监听属性相当于主动订阅了属性的变化，属性发生变化时执行回调函数
- 监听属性的watcher执行优先级高于渲染watcher；
- deep 设置为 true 用于监听对象内部值的变化
- immediate 设置为 true 将立即以表达式的当前值触发回调
 

### vue 组件通讯的方式有

1. props / $emit
    - 单向数据流
    - 父组件通过 props 的方式向子组件传递数据
    - 子组件通过 $emit 向父组件通讯

2. $parent / $children
    - 通过 $parent 和 $children 来访问组件的实例，拿到组件的实例可以访问组件的方法和 data

3. provide / inject
    - provide 提供变量
    - inject 来注入 provide 变量
    - 不管子组件调用嵌套有多深，只要调用了inject 那么就可以注入provide中的数据，
    而不局限于只能从当前父组件的props属性中回去数据
    
4. ref / refs
    - ref 绑定 组件
    - refs 访问绑定的组件的实例

5. vuex
    - 待定
6. $attrs / $listeners
    - 待定
    
### vue-router
 
1. 当用户执行 Vue.use(VueRouter) 的时候，实际上就是在执行 install 函数
    - 为 vue 的原型上注入 router 
    - mixin beforeCreate
    - 将router-link、router-view组件注册为vue全局组件
2. router 安装最重重要的一步是利用 vue.mixin 方法，把 beforeCreate 和 destroyed 钩子函数注入到每一个组件中。

3. 然后 根 vue 实例同时，会调用 beforeCreate 钩子，这里面执行
    - 调用 Vue.util.defineReactive 方法，把 router 变成响应式对象。（主要的）
    - 然后赋值 _router，这样原型上就可以访问 $router
    - 然后执行 _router.init() 初始化 router
    
4. 当 hash 或 history 更新后都触发 $router 的更新机制，调用实例的 vm.render() 方法进行重新渲染

**hash 模式**

使用 window.location.hash 属性，以及 onhashchange 事件，可以实现监听浏览器地址 hash 值的变化，执行相应的js切换页面

**history 模式**

服务端 需要配置所有的路由都要重定向到根页面

nginx 配置到 根路径下面（qiankun 遇到过）

- H5的新API，pushState 和 replaceState 通过这两个 API 改变url地址不会发送请求。
- 同时还有 popstate 事件


### vuex
vuex的核心原理就是：
1. 在install阶段调用了 Vue.mixin() 方法，利用钩子函数 beofreCreate 给所有组件注册 $stroe，这样
在所有的页面上都能获取到this.$stroe的属性；

2. 使用 resetStoreVM 方法生成了一个新的 vue 实例。
    - 并且把这个实例赋值给 store.vm
    - 接下来又给这个实例的 data 上，赋值了 $$state 属性
    - $$state 的值就是 state，也就是我们定义到 state 上的数据
    - 这样就保证了 state 上的数据被监控了，所以 state 里边的属性发生变化时，视图会更新;
    
当我们获取state上的数据的时候，实际上调用了stroe里的this._vm.data.$$state
```javascript
store._vm = new Vue({
  data: {
    $$state: state
  },
  computed
})
get state () {
  return this._vm._data.$$state
}
```
      

### 为什么循环的时候要加上key

加上key之后，当数据再次更新，新旧虚拟dom进行 diff算法对比的时候，
如果发下key相同的两组 Vnode，就可以直接拿来复用，而不用删除就节点后在创建新节点，提高 diff 算法效率

### 总结 diff 算法的过程
- 新旧节点不同：创建新节点 => 更新节点占位符 => 删除旧节点
- 

    
 

### Virtual（虚拟） Dom 的优势在哪里？

首先：
- dom 引擎、js 引擎是相互独立的，但又在同一个线程里面（主线程）
- js 代码调用 dom API 必须挂起 js 引擎，
- 传入参数数据等、然后 dom 引擎激活，DOM 重绘后可能与返回值
- 然后在激活 JS 引擎并继续执行类似频繁的 DOM API调用
- 且浏览器厂商做批量优化处理
- 引擎之前的频繁切换，若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会增加更大的性能消耗


其次是 VDOM 和真实 DOM 的区别和优化：

1. 虚拟 DOM 不会立马进行排版和重绘操作

2. 虚拟 DOM 进行频繁修改后，然后一次性的比较并修改 DOM 中需要改的部分，
最后在真实 DOM 中进行排版与重绘，减少过多的 DOM 节点排版和重绘消耗

3. 虚拟 DOM 有效的降低大面积真实 DOM 的重绘和排版，因为最后与真实 DOM 比较差异，可以只渲染局部

## 性能优化

### 重绘和回流

回流：

> 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。

回流必将引起重绘，而重绘不一定引起回流

1. 尺寸、位置、显示、隐藏 `dispaly:none/block` 发生了改变的时候，导致页面需要重新构建，
2. 添加或删除可见的 dom 元素

重绘：当元素的某些样式，比如背景色、border颜色发生变化时，但不影响页面布局，这就是重绘；


优化方法：

1.给dom 添加 class，而不是修改样式
2.如果需要对dom进行多次样式修改，也可以先将dom隐藏掉，修改完在显示出来（这样只产生两次回流：显示、隐藏）

## webpack （头大的webpack）


### webpack 工作流程
1. 参数解析
2. 找到入口文件
3. 调用 Loader 编译文件
4. 遍历 AST，收集依赖
5. 生成 Chunk
6. 输出文件

### 打包加速的方法
- 多线程编译，加快编译速度：thread-loader（四软特）、happypack
- 第三方依赖外链 script 引入：vue、ui组件、JQuery等
- Tree Shaking（谁给ing）摇树：基于es6 提供的模块系统，对代码惊喜静态分析，
并在压缩阶段将代码中死代码（dead code）移除，减少代码体积

### webpack 常用的插件
- TerserPlugin（特si）（老版本用UglifyJsPlugin）：压缩代码，删除 log 日志
- CopyWebpackPlugin：复制文件，dist 目录下 复制到 /nginx/dist/ 目录
- webpack-bundle-analyzer（ban dou）（安的来ze儿）：webpack打包出来的各个文件体积大小，以便我们定位大文件，进行体积优化
- DefinePlugin：定义全局变量。项目环境下 修改 process.env，添加项目ID
- HotModuleReplacementPlugin：页面热更新插件

### 常用的 loader
- babel-loader：转换es6语法，打补丁
- style-loader：将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的js文件中
- css-loader：加载 import 进来的css


## http 网络相关的

###  http安全 前端安全问题

https://github.com/dwqs/blog/issues/68

**XSS 跨站脚本攻击**

恶意将代码注入到客户端攻击

攻击模式：
- 基于 DOM：恶意修改页面的 dom 结构，是纯粹的客户端攻击
- 存储型：例如写文章的平台，用户恶意写了一段js代码，保存文章，那么以后打开这篇文章的人都会遭到恶意代码的攻击
- 反射型：诱导用户点击恶意连接，用户点击后注入恶意脚本到客户端

预防：
- 给 cookie 设置 `httpOnly` ，禁止 js 脚本访问 cookie
- 输入检查，不要相信用户输入的内容，对输入的内容进行必要的过滤、转义，例如vue源码里面 decodingMap 对输入内容转换，转义
- 输出检查，客户端拿到数据时候，有些渲染也要进行必要过滤、转义，vue 的 v-html，


**CSRF 跨站请求伪造**

一种劫持受信任用户向服务器发送非预期请求的方式

通常情况 CSRF 攻击是借助受害者的cookie骗取服务器的信任来进行一些操作



预防：
- 服务端添加 Referer 判断
- token 验证，服务器生成token，前端请求的时候添加token，服务器校验token 是否正确

### http、https区别
- http：IP => TCP => HTTP(应用层)
- https：IP => TCP => SSL => HTTP(应用层)
- http 是明文传输数据，不安全，https 在http的基础上 使用了 ssl协议进行了加密处理，比较安全
- http 页面响应速度比 https较快，https多了 ssl 握手的过程，也就是对数据加密的过程
- http 默认端口是80，https 是 443


### http 1.0 和 http2.0 的区别

- http2.0 多路复用，多个请求都在同一个tcp上连接，http1.0 请求数据要多次连接tcp
- 相对于 http1.0，2.0 多了对消息头的压缩，减少了传输数据的大小
- 2.0 采用二进制格式传输数据，1.0是文本格式，二进制协议解析起来更高效

### https 请求过程（ssl握手）
1. 客户端请求服务器，拿到公钥

### http 缓存
ctrl + f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存

f5 刷新页面时候，跳过强缓存，但是会检测协商缓存

- 强缓存
    1. expire（有效期）
    设置一个缓存过期的时间（值为GMT时间），具体到年月日秒，在这个时间内，则直接使用缓存数据
        - 浏览器时间和服务器时间不同步
        - 缓存过期后，不管文件有木有变化，服务器都会再次读取文件返回浏览器
        - http1.0的东西，现在默认是1.1了，它的作用基本忽略  
        
    2. cache-control：
    - no-cache：不使用本地缓存，走协商缓存
    - no-store：禁止浏览器缓存数据
    - public：内容可被缓存到到客户代理服务器
    - private：内容仅能被缓存到客户端本地
- 协商缓存
    - last-modified 

### http 的状态码有那些
- 2XX：成功状态码
    - 200：服务器接收并处理成功
- 3XX：重定向
    - 301：请求的资源被永久重定向
    - 304：服务器回应客户端请求，告诉客户端本地缓存可用
- 4XX：客户端错误
    - 400：客户端请求语法错误（请求参数错误）
    - 401：请求未授权，需要认证用户的身份
    - 403：没有权限访问
    - 404：访问的资源不存在
- 5XX：服务端错误
    - 500：服务器内部错误
    - 503：服务器端暂时无法处理请求（可能是过载或维护）

### 浏览器输入后回车的事情

- DNS 解析 url 对应的 ip
- 根据 ip 建立 TCP 连接（三次握手）
- 客户端发送 HTTP 请求
- 服务端处理请求，浏览器接受 http 响应
- 关闭 tcp 连接（四次挥手）
- 浏览器渲染页面，创建渲染树

#### 渲染页面的过程以及遇到的问题
**流程：**

1. 浏览器从上到下解析 html 文档，创建 dom 树
2. 解析 css 生成 cssom （css 规则树）
3. 解析完成后，浏览器会根据 dom 树和 css 规则树来构造渲染树（Render Tree）
4. 根据渲染树的节点，布局到屏幕的正确的位置
5. 遍历渲染树所有节点，绘制页面

**浏览器在创建 dom 树过程：**
- 遇到 css 的时候：会异步下载，生成异步的 css 规则树，不会堵塞 dom 树的出构建，但是会影响渲染树的最终生成，
因为渲染树有 dom 树和 css 规则树组成

- 遇到 js的时候：dom 树构建会停止，会先去加载和执行 js 代码，会中断构建 dom 树，
如果这时候 js 操作页面样式，还有可能造成，重绘或回流

**这时候产生的优化问题：**

- css 优化：首屏页面 css 独立出来，放到 style 里面 内行加载

- JS 优化：在页面的最下面引入 js，或者使用 defer 属性，这样页面在渲染会在渲染完成后加载
    - async：异步加载，下载过程中不会影响到 html 的解析，但是下载完成后会立即执行，对堵塞 html 解析
    - defer：异步加载，下载过程中不会形象到 html 的解析，会在所有的元素解析完成后，DOMContentLoaded 事件之前触发完成

### tcp 的三次握手

**三次过程：**

- 客户端：你能收我消息么？
- 服务端：可以的，你能接收到我的回复吗？
- 客户端：可以的，那我们开始聊正事把

1. 为啥是3次：
   - 三次是最少的安全次数，两次不安全，四次浪费资源。
   - 避免历史链接，确定客户端发的请求是这次通讯的人

2. 为啥不是4次：
   - 四次浪费资源

### tcp 协议 四次挥手

TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道：

- 通道1：客户端的输出链接服务端的输入
  
- 通道2：客户端的输入链接服务端的输出

两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。


关闭通道：

- 客户端：我要关闭通道了
  
- 服务端：好的你关闭，我这边也要关闭通道了
    
- 服务端：我也要关闭通道了
  
- 客户端：好的，你关闭吧，我也吧这个通道关闭了


1. 为什么不能是两次
    - 无法确认服务端是否能到断开消息，还有服务端可能还有消息未发送完

2. 为什么不能是三次
    - 三次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。


<img src="./img/img4.png" width="600"> 

### 一个 tcp 连接能发几个 http 请求


