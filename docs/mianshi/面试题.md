# 常见面试题


## JavaScript

### common.js 和 es6 中模块引入的区别？

commonJs： `require` / `exports` 是一种模块语法，最初应用用 `nodejs` 成为 `nodejs` 的模块规范

ES6 模块：
`import` / `export` 

- `commonJs` 模块是输出的是一个值的拷贝，ES6 模块输出的是值的引用
- `commonJs` 模块是运行是加载，ES6 模块是编译时输出接口
- `commonJs` 是单个值导出，ES6 模块可以导出多个
- `commonJs` 是动态语法可以写判断，ES6 模块静态语法只能写在顶层（如果要写在别的地方，可以使用 `import()` 函数实现）
    - `require('url' + a + b)` 不会报错
    - `import 'url' + a + b `会报错，可以使用 `import('url' + a + b)`
- `commonJs` 的 `this` 是当前的模块，ES6 模块的 `this` 是 `undefined`

## 框架相关的

### vue template 怎么理解

vue 的模版语法，是一种描述视图的标记语言，通过 vue 的 vue-template-compiler 解析成 render 函数，
再通过 vnode 加上 diff 算法统一替换 dom 形成证实的视图，所以 vue 和 react 在本质上类似。
也就是说 vue 也可以和 react 一样通过 jsx 来描绘视图，不同的是 vue 提高了一套更符合前端思维的标记语言

生成jsx的语法糖，主要是用来生成描述页面的对象

### vue 的 计算属性 VS 监听属性

#### 计算属性
- 计算属性被访问的时触发 getter 函数，执行用户返回的计算结果，
如果返回值发生来变化才触发更新（有缓存，依赖发生变化才执行）

- 依赖属性更新：计算属性会成为，依赖属性的订阅者，依赖变量发生变化改变则触发计算属性重新计算

- 计算属性有 lazy 和 active两种模式，active模式依赖更新立即计算，lazy模式依赖变化仅设置this.dirty = true，等访问计算属性时再重新计算，并加入缓存。


#### 监听属性
- 监听属性相当于主动订阅了属性的变化，属性发生变化时执行回调函数
- 监听属性的watcher执行优先级高于渲染watcher；
- deep 设置为 true 用于监听对象内部值的变化
- immediate 设置为 true 将立即以表达式的当前值触发回调
 

### vue 组件通讯的方式有

#### props / $emit

单向数据流

父组件通过 props 的方式向子组件传递数据

子组件通过 $emit 向父组件通讯

#### $parent / $children

通过 $parent 和 $children 来访问组件的实例，拿到组件的实例可以访问组件的方法和 data

#### provide / inject

provide 提供变量

inject 来注入 provide 变量

不管子组件调用嵌套有多深，只要调用了inject 那么就可以注入provide中的数据，
而不局限于只能从当前父组件的props属性中回去数据


#### ref / refs

ref 绑定 组件

refs 访问绑定的组件的实例


#### vuex

#### $attrs / $listeners

### Virtual（虚拟） Dom 的优势在哪里？

首先：
- dom 引擎、js 引擎是相互独立的，但又在同一个线程里面（主线程）
- js 代码调用 dom API 必须挂起 js 引擎，
- 传入参数数据等、然后 dom 引擎激活，DOM 重绘后可能与返回值
- 然后在激活 JS 引擎并继续执行类似频繁的 DOM API调用
- 且浏览器厂商做批量优化处理
- 引擎之前的频繁切换，若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会增加更大的性能消耗


其次是 VDOM 和真实 DOM 的区别和优化：

1. 虚拟 DOM 不会立马进行排版和重绘操作

2. 虚拟 DOM 进行频繁修改后，然后一次性的比较并修改 DOM 中需要改的部分，
最后在真实 DOM 中进行排版与重绘，减少过多的 DOM 节点排版和重绘消耗

3. 虚拟 DOM 有效的降低大面积真实 DOM 的重绘和排版，因为最后与真实 DOM 比较差异，可以只渲染局部

## 性能优化

### 重绘和回流

回流：

> 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。

回流必将引起重绘，而重绘不一定引起回流

1. 尺寸、位置、显示、隐藏 `dispaly:none/block` 发生了改变的时候，导致页面需要重新构建，
2. 添加或删除可见的 dom 元素

重绘：当元素的某些样式，比如背景色、border颜色发生变化时，但不影响页面布局，这就是重绘；


优化方法：

1.给dom 添加 class，而不是修改样式
2.如果需要对dom进行多次样式修改，也可以先将dom隐藏掉，修改完在显示出来（这样只产生两次回流：显示、隐藏）

## webpack （头大的webpack）
### webpack 工作流程

1. 参数解析
2. 找到入口文件
3. 调用 Loader 编译文件
4. 遍历 AST，收集依赖
5. 生成 Chunk
6. 输出文件

## http 网络相关的

### http、https区别

- http 是明文传输数据，不安全，https 在http的基础上 使用了 ssl协议进行了加密处理，比较安全
- http 页面响应速度比 https较快，https多了 ssl 握手的过程，也就是对数据加密的过程
- http默认端口是80，https 是 443

### https 请求过程（ssl握手） todo

1. 客户端请求服务器，拿到公钥


### http 的状态码有那些
- 2XX：成功状态码
    - 200：服务器接收并处理成功
- 3XX：重定向
    - 301：请求的资源被永久重定向
    - 304：服务器回应客户端请求，告诉客户端本地缓存可用
- 4XX：客户端错误
    - 400：客户端请求语法错误（请求参数错误）
    - 401：请求未授权，需要认证用户的身份
    - 403：没有权限访问
    - 404：访问的资源不存在
- 5XX：服务端错误
    - 500：服务器内部错误
    - 503：服务器端暂时无法处理请求（可能是过载或维护）

### 浏览器输入后回车的事情

- DNC 解析 url 对应的 ip
- 根据 ip 建立 TCP 连接（三次握手）
- 客户端发送 HTTP 请求
- 服务端处理请求，浏览器接受 http 响应
- 关闭 tcp 连接（四次挥手）
- 浏览器渲染页面，创建渲染树

#### 渲染页面的过程以及遇到的问题

**流程：**

1. 浏览器从上到下解析 html 文档，创建 dom 树
2. 解析 css 生成 cssom （css 规则树）
3. 解析完成后，浏览器会根据 dom 树和 css 规则树来构造渲染树（Render Tree）
4. 根据渲染树的节点，布局到屏幕的正确的位置
5. 遍历渲染树所有节点，绘制页面


**浏览器在创建 dom 树过程：**

- 遇到 css 的时候：会异步下载，生成异步的 css 规则树，不会堵塞 dom 树的出构建，但是会影响渲染树的最终生成，
因为渲染树有 dom 树和 css 规则树组成

- 遇到 js的时候：dom 树构建会停止，会先去加载和执行 js 代码，会中断构建 dom 树，
如果这时候 js 操作页面样式，还有可能造成，重绘或回流

**这时候产生的优化问题：**

- css 优化：首屏页面 css 独立出来，放到 style 里面 内行加载

- JS 优化：在页面的最下面引入 js，或者使用 defer 属性，这样页面在渲染会在渲染完成后加载
    - async：异步加载，下载过程中不会影响到 html 的解析，但是下载完成后会立即执行，对堵塞 html 解析
    - defer：异步加载，下载过程中不会形象到 html 的解析，会在所有的元素解析完成后，DOMContentLoaded 事件之前触发完成

### http 1.0 和 http2.0 的区别

### tcp 的三次握手

#### 三次过程：

- 客户端：你能收我消息么？
- 服务端：可以的，你能接收到我的回复吗？
- 客户端：可以的，那我们开始聊正事把

1. 为啥是3次：
   - 三次是最少的安全次数，两次不安全，四次浪费资源。
   - 避免历史链接，确定客户端发的请求是这次通讯的人

2. 为啥不是4次：
   - 四次浪费资源

### tcp 协议 四次挥手

#### 四次挥手过程：

TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道：

- 通道1：客户端的输出链接服务端的输入
  
- 通道2：客户端的输入链接服务端的输出

两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。


关闭通道：

- 客户端：我要关闭通道了
  
- 服务端：好的你关闭，我这边也要关闭通道了
    
- 服务端：我也要关闭通道了
  
- 客户端：好的，你关闭吧，我也吧这个通道关闭了


1. 为什么不能是两次
    - 无法确认服务端是否能到断开消息，还有服务端可能还有消息未发送完

2. 为什么不能是三次
    - 三次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。


<img src="./img/img4.png" width="600"> 

### 一个 tcp 连接能发几个 http 请求


