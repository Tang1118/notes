# 常见面试题


## JavaScript

### common.js 和 es6 中模块引入的区别？

commonJs： `require` / `exports` 是一种模块语法，最初应用用 `nodejs` 成为 `nodejs` 的模块规范

ES6 模块：
`import` / `export` 

- `commonJs` 模块是输出的是一个值的拷贝，ES6 模块输出的是值的引用
- `commonJs` 模块是运行是加载，ES6 模块是编译时输出接口
- `commonJs` 是单个值导出，ES6 模块可以导出多个
- `commonJs` 是动态语法可以写判断，ES6 模块静态语法只能写在顶层（如果要写在别的地方，可以使用 `import()` 函数实现）
    - `require('url' + a + b)` 不会报错
    - `import 'url' + a + b `会报错，可以使用 `import('url' + a + b)`
- `commonJs` 的 `this` 是当前的模块，ES6 模块的 `this` 是 `undefined`

## 框架相关的

### 计算属性 VS 侦听属性


### Virtual（虚拟） Dom 的优势在哪里？

首先：
- dom 引擎、js 引擎是相互独立的，但又在同一个线程里面（主线程）
- js 代码调用 dom API 必须挂起 js 引擎，
- 传入参数数据等、然后 dom 引擎激活，DOM 重绘后可能与返回值
- 然后在激活 JS 引擎并继续执行类似频繁的 DOM API调用
- 且浏览器厂商做批量优化处理
- 引擎之前的频繁切换，若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会增加更大的性能消耗


其次是 VDOM 和真实 DOM 的区别和优化：

1. 虚拟 DOM 不会立马进行排版和重绘操作

2. 虚拟 DOM 进行频繁修改后，然后一次性的比较并修改 DOM 中需要改的部分，
最后在真实 DOM 中进行排版与重绘，减少过多的 DOM 节点排版和重绘消耗

3. 虚拟 DOM 有效的降低大面积真实 DOM 的重绘和排版，因为最后与真实 DOM 比较差异，可以只渲染局部


## 性能优化

### 重绘和回流

回流：

> 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。

回流必将引起重绘，而重绘不一定引起回流

1. 尺寸、位置、显示、隐藏 `dispaly:none/block` 发生了改变的时候，导致页面需要重新构建，
2. 添加或删除可见的 dom 元素

重绘：当元素的某些样式，比如背景色、border颜色发生变化时，但不影响页面布局，这就是重绘；


优化方法：

1.给dom 添加 class，而不是修改样式
2.如果需要对dom进行多次样式修改，也可以先将dom隐藏掉，修改完在显示出来（这样只产生两次回流：显示、隐藏）


## http 网络相关的

### 浏览器输入后回车的事情

- DNC 解析 url 对应的 ip
- 根据 ip 建立 TCP 连接（三次握手）
- 客户端发送 HTTP 请求
- 服务端处理请求，浏览器接受 http 响应
- 关闭 tcp 连接（四次挥手）
- 浏览器渲染页面，创建渲染树

#### 渲染页面的过程以及遇到的问题

**流程：**

1. 浏览器从上到下解析 html 文档，创建 dom 树
2. 解析 css 生成 cssom （css 规则树）
3. 解析完成后，浏览器会根据 dom 树和 css 规则树来构造渲染树（Render Tree）
4. 根据渲染树的节点，布局到屏幕的正确的位置
5. 遍历渲染树所有节点，绘制页面


**浏览器在创建 dom 树过程：**

- 遇到 css 的时候：会异步下载，生成异步的 css 规则树，不会堵塞 dom 树的出构建，但是会影响渲染树的最终生成，
因为渲染树有 dom 树和 css 规则树组成

- 遇到 js的时候：dom 树构建会停止，会先去加载和执行 js 代码，会中断构建 dom 树，
如果这时候 js 操作页面样式，还有可能造成，重绘或回流

**这时候产生的优化问题：**

- css 优化：首屏页面 css 独立出来，放到 style 里面 内行加载

- JS 优化：在页面的最下面引入 js，或者使用 defer 属性，这样页面在渲染会在渲染完成后加载
    - async：异步加载，下载过程中不会影响到 html 的解析，但是下载完成后会立即执行，对堵塞 html 解析
    - defer：异步加载，下载过程中不会形象到 html 的解析，会在所有的元素解析完成后，DOMContentLoaded 事件之前触发完成







### http 1.0 和 http2.0 的区别


### tcp 的三次握手

#### 三次过程：

- 客户端：你能收我消息么？
- 服务端：可以的，你能接收到我的回复吗？
- 客户端：可以的，那我们开始聊正事把

1. 为啥是3次：
   - 三次是最少的安全次数，两次不安全，四次浪费资源。
   - 避免历史链接，确定客户端发的请求是这次通讯的人

2. 为啥不是4次：
   - 四次浪费资源

### tcp 协议 四次挥手

#### 四次挥手过程：

TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道：

- 通道1：客户端的输出链接服务端的输入
  
- 通道2：客户端的输入链接服务端的输出

两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。


关闭通道：

- 客户端：我要关闭通道了
  
- 服务端：好的你关闭，我这边也要关闭通道了
    
- 服务端：我也要关闭通道了
  
- 客户端：好的，你关闭吧，我也吧这个通道关闭了


1. 为什么不能是两次
    - 无法确认服务端是否能到断开消息，还有服务端可能还有消息未发送完

2. 为什么不能是三次
    - 三次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。


<img src="./img/img4.png" width="600"> 


### 一个 tcp 连接能发几个 http 请求

