# 作用域和作用域链

## 作用域
### 什么是作用域

作用域可以理解成一个独立地盘，让变量不会泄露，暴露出去。
也就是说，作用域最大的作用就是隔离变量，不同作用域下的同样名称变量不会有冲突。


**ES6 之前 JS 是没有块级作用域的，只有全局作用域和函数作用域。**
ES6 的到来为我们提供了 **快级作用域**，可以通过 let 和 const 来体现

###  全局作用域

**最外层的函数和在外层外面定义的变量拥有全局作用域**

```javascript
var outVar = '最外层变量'

// 最外层函数
function outFun() {
  var inVar = '内层变量'
  
  // 内层函数 innerFun
  function innerFun() {
    console.log(inVar)
  }
  
  innerFun()
}


console.log(outVar)   // ==> 最外层变量

outFun()              // ==> 内层变量

console.log(inVar)    // ==> inVar is not defined

innerFun()            // ==> innerFun is not defined
```

所有**未定义的直接赋值的变量**，会自动声明为拥有全局作用域

```javascript
function fun2() {
  var1 = '未定义直接赋值的变量'

  var var2 = '内部变量'
}

fun2() // 要执行这个函数，否则不知道里面是啥

console.log(var1) // 未定义直接赋值的变量 (全局变量，在函数 fun2执行后，会挂载到 window 下) 

console.log(var2) // 报错（函数内部变量，无法访问）
```

**所有 window 对象的属性拥有全局作用域**

全局作用域的弊端：污染全局命名空间，容易引起命名冲突

### 函数作用域

函数作用域是指 **函数内部声明** 的变量，和全局作用域相反

局部作用域一般只是在固定的代码片段内可以访问到，常见是函数内部

jQuery、Zepto 等库的源码，代码放在 ``(function(){....})()`` 中，变量不会被外泄和暴露，
不会污染到外面，不会对其他js库造成影响

```javascript

function fun3() {
  var var1 = '内部变量'

  function innerSay() {
    alert(var1)
  }

  innerSay()  
}

alert(var1) // 报错 （var1 是函数内部的变量，访问不到）

innerSay() // 报错 （innerSay 是函数内部的函数，访问不到）

```

####  作用域分层
## 参考
[深入理解JavaScript作用域和作用域链](https://juejin.cn/post/6844903797135769614#heading-3)
