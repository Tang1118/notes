import{_ as l,c as e,o as i,S as a}from"./chunks/framework.9c4db3f7.js";const o="/blog/assets/img-1.6c40721c.png",r="/blog/assets/img-2.d5bfb227.png",t="/blog/assets/img-3.d00be78a.png",q=JSON.parse('{"title":"渲染页面过程","description":"","frontmatter":{},"headers":[],"relativePath":"fe/browser/rendering.md","filePath":"fe/browser/rendering.md","lastUpdated":1703224412000}'),c={name:"fe/browser/rendering.md"},d=a('<h1 id="渲染页面过程" tabindex="-1">渲染页面过程 <a class="header-anchor" href="#渲染页面过程" aria-label="Permalink to &quot;渲染页面过程&quot;">​</a></h1><ul><li>渲染器进程：核心任务就是把 <code>html</code>、<code>css</code>、<code>js</code>、<code>image</code> 等渲染成用户可交互的web页面</li><li>主线程：DOM =&gt; style =&gt; layout（布局） =&gt; paint（绘制） =&gt; layer（图层）</li><li>合成器线程：图层切分快 和 合成器帧发送</li><li>栅格线程：图块栅格化，图块的信息</li></ul><h2 id="浏览器的进程与线程" tabindex="-1">浏览器的进程与线程 <a class="header-anchor" href="#浏览器的进程与线程" aria-label="Permalink to &quot;浏览器的进程与线程&quot;">​</a></h2><p><a href="https://juejin.cn/post/6991849728493256741" target="_blank" rel="noreferrer">浏览器的进程与线程</a></p><h3 id="chrome-打开一个页面有多少进程" tabindex="-1">Chrome 打开一个页面有多少进程 <a class="header-anchor" href="#chrome-打开一个页面有多少进程" aria-label="Permalink to &quot;Chrome 打开一个页面有多少进程&quot;">​</a></h3><p>浏览器从关闭到启动，然后新开一个页面至少需要：</p><p><code>1个浏览器进程</code>，<code>1个GPU进程</code>，<code>1个网络进程</code>，和<code>1个渲染进程</code>，一共4个进程；</p><p>后续如果再打开新的标签页：</p><ul><li><p>浏览器进程，GPU进程，网络进程是共享的，不会重新启动，然后默认情况下会为每一个标签页配置一个渲染进程；</p></li><li><p>但是也有例外，比如从A页面里面打开一个新的页面B页面，而A页面和B页面又属于同一站点的话，A和B就共用一个渲染进程，其他情况就为B创建一个新的渲染进程</p></li></ul><p>最新的Chrome浏览器包括：<code>1个浏览器主进程</code>，<code>1个GPU进程</code>，<code>1个网络进程</code>，<code>多个渲染进程</code>，和<code>多个插件进程</code></p><ul><li><code>浏览器进程</code>： 负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能</li><li><code>GPU进程</code>：负责整个浏览器界面的渲染。Chrome刚开始发布的时候是没有GPU进程的，而使用GPU的初衷是为了实现3D CSS效果，只是后面网页、Chrome的UI界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后Chrome在多进程架构上也引入了GPU进程</li><li><code>网络进程</code>：负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程</li><li><code>插件进程</code>：主要是负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响</li><li><code>渲染进程</code>：负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下Chrome会为每个Tab标签页创建一个渲染进程</li></ul><h3 id="渲染进程中的线程" tabindex="-1">渲染进程中的线程 <a class="header-anchor" href="#渲染进程中的线程" aria-label="Permalink to &quot;渲染进程中的线程&quot;">​</a></h3><ul><li><code>GUI渲染线程</code>：负责渲染页面，解析html和CSS、构建DOM树、CSSOM树、渲染树、和绘制页面，重绘重排也是在该线程执行</li><li><code>JS引擎线程</code>：一个tab页中只有一个JS引擎线程(单线程)，负责解析和执行JS。它GUI渲染进程不能同时执行，只能一个一个来，如果JS执行过长就会导致阻塞掉帧</li><li><code>计时器线程</code>：指setInterval和setTimeout，因为JS引擎是单线程的，所以如果处于阻塞状态，那么计时器就会不准了，所以需要单独的线程来负责计时器工作</li><li><code>异步http请求线程</code>： XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行</li><li><code>事件触发线程</code>：主要用来控制事件循环，比如JS执行遇到计时器，AJAX异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到待处理队列的队尾，等JS引擎处理</li></ul><h2 id="渲染页面" tabindex="-1">渲染页面 <a class="header-anchor" href="#渲染页面" aria-label="Permalink to &quot;渲染页面&quot;">​</a></h2><ol><li><p>解析 html（DOM Tree）<code>主线程</code></p><ol><li>解析 html 异步解析</li><li>通过词法分析，将 <code>html</code> 解析多个标记</li><li>根据标记，进行 <code>DOM Tree</code> 构造</li><li>构造过程中创建 <code>document</code> 对象</li><li>以 <code>document</code> 为根节点 <code>DOM Tree</code>，不断进行修改，向其中添加各种元素，创建 <code>DOM Tree</code></li></ol></li><li><p>解析 css （style Tree）<code>主线程</code></p><ol><li>解析 css，并确定 DOM 节点的计算样式</li><li>如果没有就用浏览器默认的 css</li><li>生成 <code>style Tree</code></li><li>如果 link 会将引入的css 全部解析完成 同步解析</li></ol></li><li><p>创建 layout 布局 （layout Tree）<code>主线程</code></p><ol><li>主线程根据 DOM Tree 和 style Tree 来创建 layout Tree</li><li>layout Tree 每个节点会记录 x y 坐标和边框大小等</li><li>DOM Tree 和 layout Tree 不是一一对应的 <ol><li>DOM Tree 设置了 display：none 的，layout 不会显示</li><li>在 css 伪类中添加了 content 内容的元素，content的内容 不会出现在 DOM Tree 上</li><li>伪类 是通过 css 解析的不会出现在的 dom 上</li></ol></li></ol></li><li><p>创建绘制表（paint）<code>主线程</code></p><ol><li>根据 layout 创建绘制记录表</li><li>确定绘制顺序，z-inde 这些</li></ol></li><li><p>生成 layer Tree（图层）<code>主线程</code></p><ol><li>根据 layout Tree 生成 layer Tree（图层）</li><li>并把 layout Tree 和 layer Tree 传递给合成器线程（通过IPC传递）</li></ol></li><li><p>分图层和切块 <code>合成器线程</code></p><ol><li>合成器线程将图层切分为图块</li><li>将图块发送诶栅格线程</li></ol></li><li><p>栅格化 <code>栅格线程</code></p><ol><li>对图块进行栅格化，</li><li>产生图块信息</li><li>并把图块信息传递给合成器</li></ol></li><li><p>渲染</p><ol><li>合成器进程收到栅格线程的图块信息，</li><li>根据信息合成器线程合成一个合成器帧</li><li>通过 IPC 将合成器帧 传递得浏览器进程</li><li>浏览器进程再传到 CPU 进行渲染</li></ol></li></ol><h2 id="重排和重绘问题" tabindex="-1">重排和重绘问题 <a class="header-anchor" href="#重排和重绘问题" aria-label="Permalink to &quot;重排和重绘问题&quot;">​</a></h2><ul><li>重排：当修改元素尺寸和位置时，会触发样式计算（style）、布局（layout）、绘制（paint）以及后面所有流程</li><li>重绘：当修改元素的颜色时，会触发样式计算（style）以及绘制（paint）</li></ul><p>反复做的重排和重绘会导致掉帧卡顿，重排和重绘都会占用主线程，JS会执行会阻塞主线程</p><p>触发回流的操作：</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化</li><li>浏览器的窗口尺寸变化</li></ul><p>重绘是只重新像素绘制，当元素样式的改变不影响布局时触发。</p><p>回流=计算样式+布局+分层+绘制；重绘=绘制。故回流对性能的影响更大</p><p>所以应该尽量避免回流和重绘。比如利用GPU加速来实现样式修改，<code>transform / opacity / filters</code>这些属性的修改都不是在主线程完成的，不会重绘，更不会回流。</p><h3 id="重排" tabindex="-1">重排 <a class="header-anchor" href="#重排" aria-label="Permalink to &quot;重排&quot;">​</a></h3><p><img src="'+o+'" alt="重排"></p><h3 id="重绘" tabindex="-1">重绘 <a class="header-anchor" href="#重绘" aria-label="Permalink to &quot;重绘&quot;">​</a></h3><p><img src="'+r+'" alt="重绘"></p><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><h3 id="requestanimationframe" tabindex="-1">requestAnimationFrame() <a class="header-anchor" href="#requestanimationframe" aria-label="Permalink to &quot;requestAnimationFrame()&quot;">​</a></h3><blockquote><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画， 并且要求浏览器在 <strong>下次重绘之前调用</strong> 指定的回调函数更新动画。 该方法需要传入一个回调函数作为参数，该回调函数会在浏览器 <strong>下一次重绘之前</strong> 执行</p></blockquote><ul><li>方法在<strong>每一帧之前调</strong>用告诉浏览器——你希望执行一个动画，并且要求浏览器在下次<strong>重绘之前</strong>调用指定的回调函数更新动画</li><li>把 js 任务 分成更小的任务块</li><li>在每一帧完成前暂停js 执行归还主线程</li><li>下一帧开始时主线程就可以按时执行布局和绘制</li><li>react 最新的渲染引擎，react Filer用这个api 做了很多优化</li><li>中断（Generator）和 异步的思想</li></ul><h3 id="transform" tabindex="-1">transform <a class="header-anchor" href="#transform" aria-label="Permalink to &quot;transform&quot;">​</a></h3><ul><li>该属性实现动画不会经过布局和绘制（不会占用主线程）</li><li>会运行在 <code>合成器线程</code> 和 <code>栅格线程</code> 中，不受主线程的js执行的影响</li><li>transform 实现动画不需要经过布局（layout）、绘制（paint）样式计算等操作节省了运算时间</li></ul><h2 id="阻塞渲染的" tabindex="-1">阻塞渲染的 <a class="header-anchor" href="#阻塞渲染的" aria-label="Permalink to &quot;阻塞渲染的&quot;">​</a></h2><ul><li>css 阻塞 <ol><li>style标签： <ul><li>由 html 解析器解析（异步）</li><li>边加载边渲染</li><li>不阻塞浏览器渲染</li><li>不阻塞 DOM 解析</li><li>异步解析的，分组解析渲染，容易出现闪屏现象</li></ul></li><li>link 引入css：（推荐使用） <ul><li>由 css 解析器进行解析 (同步)</li><li>解析完成后</li><li>不阻塞 DOM 解析</li><li>阻塞浏览器渲染</li><li>阻塞 script 标签中 js 执行</li><li>解析 css 样式，只解析一次，是同步的，等所有的 css 全部加载完再解析</li></ul></li><li>style：内联 <ol><li>一进页面，就看见了盒子，这个盒子背景颜色 赤橙红绿青蓝紫 闪一遍，最终颜色是紫色 （过程都看出来）</li></ol></li><li>link：外链 <ol><li>进页面先空白，因为这个时候在请求资源、解析，等着 Stylesheet 解析完了，统一渲染，盒子出来，背景颜色是紫色</li></ol></li></ol></li><li>JS 阻塞 <ol><li>阻塞后续DOM解析</li><li>阻塞渲染</li><li>阻塞后续JS执行</li><li>图片需要通过网络下载或从缓存中直接加载不会阻塞 html 解析，因为他们不会影响 dom 的生成</li></ol></li></ul><h2 id="阻塞优化" tabindex="-1">阻塞优化 <a class="header-anchor" href="#阻塞优化" aria-label="Permalink to &quot;阻塞优化&quot;">​</a></h2><ul><li><p>css 优化：</p><ol><li>首屏页面 css 独立出来，放到 style 里面內联加载，加载html的时候同时加载</li><li>使用 cdn 节点进行外部资源加速</li><li>对 css 进行压缩，比如使用（webpack、gulp等）</li><li>减少 http 资源请求次数，多个 css 文件合并</li><li>优化样式表的代码</li><li><a href="https://blog.csdn.net/Luckyzhoufangbing/article/details/108548783" target="_blank" rel="noreferrer">style 样式渲染</a></li></ol></li><li><p>JS 优化：在页面的最下面引入 js，或者使用 defer 属性，这样页面在渲染会在渲染完成后加载</p><ul><li>async：异步加载，下载过程中不会影响到 html 的解析，但是下载完成后会立即执行，对堵塞 html 解析</li><li>defer：异步加载，下载过程中不会影响到 html 的解析，会在所有的元素解析完成后，DOMContentLoaded 事件之前触发完成</li></ul></li><li><p>参考</p></li><li><p><a href="https://segmentfault.com/a/1190000022084293" target="_blank" rel="noreferrer">浏览器渲染机制</a></p></li></ul><h2 id="async、defer、preload、prefetch有什么区别" tabindex="-1">async、defer、preload、prefetch有什么区别 <a class="header-anchor" href="#async、defer、preload、prefetch有什么区别" aria-label="Permalink to &quot;async、defer、preload、prefetch有什么区别&quot;">​</a></h2><h3 id="async和defer有什么差别" tabindex="-1">async和defer有什么差别 <a class="header-anchor" href="#async和defer有什么差别" aria-label="Permalink to &quot;async和defer有什么差别&quot;">​</a></h3><ul><li>没有 defer 或 async，浏览器会立即加载并执行指定的脚本</li><li>async 属性表示异步执行引入的 JavaScript，经加载好，就会开始执行</li><li>defer 属性表示延迟到DOM解析完成，，DOMContentLoaded 事件之前触发完后再执行引入的 JS</li></ul><p><img src="'+t+'" alt="image"></p><h3 id="preload、prefetch有什么区别" tabindex="-1">preload、prefetch有什么区别 <a class="header-anchor" href="#preload、prefetch有什么区别" aria-label="Permalink to &quot;preload、prefetch有什么区别&quot;">​</a></h3><ul><li>preload：以高优先级为当前页面加载资源；</li><li>prefetch：以低优先级为后面的页面加载未来需要的资源，只会在空闲时才去加载；</li></ul><p>无论是preload还是prefetch，都只会加载，不会执行， 如果预加载的资源被服务器设置了可以缓存cache-control那么会进入磁盘，反之只会被保存在内存中。</p>',44),s=[d];function n(h,p,u,m,f,b){return i(),e("div",null,s)}const g=l(c,[["render",n]]);export{q as __pageData,g as default};
