import{_ as t,c as l,o as i,S as e}from"./chunks/framework.9c4db3f7.js";const a="/blog/assets/img-1.31e2a705.png",P=JSON.parse('{"title":"http 相关","description":"","frontmatter":{},"headers":[],"relativePath":"fe/network/http.md","filePath":"fe/network/http.md","lastUpdated":1694074958000}'),o={name:"fe/network/http.md"},r=e('<h1 id="http-相关" tabindex="-1">http 相关 <a class="header-anchor" href="#http-相关" aria-label="Permalink to &quot;http 相关&quot;">​</a></h1><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=822#/detail/pc?id=7203" target="_blank" rel="noreferrer">HTTP 协议和前端开发有什么关系</a></p><h2 id="http-协议的演变" tabindex="-1">Http 协议的演变 <a class="header-anchor" href="#http-协议的演变" aria-label="Permalink to &quot;Http 协议的演变&quot;">​</a></h2><h3 id="_1、http-1-0-到-http-1-1-主要实现了对-tcp-连接的复用" tabindex="-1">1、HTTP/1.0 到 HTTP/1.1 ：主要实现了对 TCP 连接的复用 <a class="header-anchor" href="#_1、http-1-0-到-http-1-1-主要实现了对-tcp-连接的复用" aria-label="Permalink to &quot;1、HTTP/1.0 到 HTTP/1.1 ：主要实现了对 TCP 连接的复用&quot;">​</a></h3><p>HTTP/1.1 中引入了持久连接的概念，通过设置 <code>Connection</code> 头部为 <code>keep-alive</code> 的方式，可以让 TCP 连接不会关闭。</p><p>该功能避免了 TCP 连接的重新建立，客户端可在已建立的 TCP 连接上，长时间地对同一个服务端的发起请求。</p><h3 id="_2、http-1-1-到-http-2-主要实现了多个请求的复用" tabindex="-1">2、HTTP/1.1 到 HTTP/2：主要实现了多个请求的复用 <a class="header-anchor" href="#_2、http-1-1-到-http-2-主要实现了多个请求的复用" aria-label="Permalink to &quot;2、HTTP/1.1 到 HTTP/2：主要实现了多个请求的复用&quot;">​</a></h3><p>HTTP/2 通过将 HTTP 消息拆分为独立的帧，进行交错发送，实现在同一个连接上并行多个请求，来减少网络请求的延迟。</p><p>为了实现多路复用，HTTP/2 协议对 HTTP 头部进行了二进制编码，因此不再语义可读。</p><p>除此之外，HTTP2 还实现了 <strong>Header 压缩</strong>、<strong>服务端主动推动</strong>、<strong>流优先级</strong>等能力。</p><h3 id="_3、http-2-到-http-3-主要实现了基于-udp-协议、更快的传输。" tabindex="-1">3、HTTP/2 到 HTTP/3：主要实现了基于 UDP 协议、更快的传输。 <a class="header-anchor" href="#_3、http-2-到-http-3-主要实现了基于-udp-协议、更快的传输。" aria-label="Permalink to &quot;3、HTTP/2 到 HTTP/3：主要实现了基于 UDP 协议、更快的传输。&quot;">​</a></h3><p>HTTP/3 使用了基于 UDP 的 QUIC 协议，实现了又快又可靠的传输。</p><p>由于 UDP 协议中没有错误检查内容，因此可以更快地实现通信。</p><p>同时，QUIC 协议负责合并纠错、重建丢失的数据，解决了 UDP 协议传输丢包的问题</p><p>使用场景：游戏、直播</p><h2 id="http-缓存" tabindex="-1">http 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;http 缓存&quot;">​</a></h2><p><a href="https://www.cnblogs.com/wonyun/p/5524617.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/wonyun/p/5524617.html</a></p><p>强缓存与协商缓存的区别，可以用下表来进行描述：</p><table><thead><tr><th>名称</th><th>资源方式</th><th>状态码</th><th>发送请求到服务器</th></tr></thead><tbody><tr><td>强缓存</td><td>从缓存中获取</td><td>200 (from cache)</td><td>否，直接从缓存取</td></tr><tr><td>协商缓存</td><td>从缓存中获取</td><td>304 (not modified)</td><td>是，通过服务器来告知缓存是否可用</td></tr></tbody></table><h3 id="强缓存-本地缓存" tabindex="-1">强缓存（本地缓存） <a class="header-anchor" href="#强缓存-本地缓存" aria-label="Permalink to &quot;强缓存（本地缓存）&quot;">​</a></h3><ul><li>expire（有效期） <ul><li>设置一个缓存过期的时间（值为GMT时间），具体到年月日秒，在这个时间内，则直接使用缓存数据</li><li>浏览器时间和服务器时间不同步</li><li>缓存过期后，不管文件有木有变化，服务器都会再次读取文件返回浏览器</li><li>http1.0的东西，现在默认是1.1了，它的作用基本忽略</li></ul></li><li>cache-control： <ul><li>max-age：max-age=n秒，告诉客户端n秒后失效，n秒内都是使用本地缓存</li><li>no-cache：不使用本地缓存，走协商缓存</li><li>no-store：禁止浏览器缓存数据</li><li>public：可以别所有用户缓存，内容可被缓存到到客户代理服务器</li><li>private：内容仅能被缓存到客户端本地</li></ul></li></ul><p>如果 cache-control 和 expires 同时存在的话，cache-control 优先级高于 expires</p><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><p>协商缓存是有服务器来确定缓存资源是否可用</p><ul><li>响应头 上配置 last-modified 或者 Etag</li><li>请求头 上配置 if-modified-since 或者 if-none-match</li></ul><ol><li><p>Last-Modified / If-Modified-Since</p><ul><li><p>浏览器第一次 请求服务器资源，服务器返回资源，并且在 <code>响应头 respone header</code> 加上 <code>last-modified</code> 的 header，这个表示资源在服务器上最后修改的时间</p></li><li><p>浏览器再次 请求服务器资源，<code>请求头 request header</code> 添加 <code>If-Modified-Since</code> 的 header， 这个 header 的值是上一次请求返回的 <code>last-modified</code> 的值</p></li><li><p>服务器再次收到资源请求时候，根据 if-modified-since 和 资源在服务器上最后的修改时间判断 资源是否有变化。</p><ul><li>没有变化 返回 304 not modified 的同时，返回响应头的 last-modified 不会改变</li><li>有变化就正常返回资源</li></ul></li><li><p>浏览器接收到 304 的响应，就会从缓存中加载资源</p></li><li><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时候，last-modified 会被重新更新</p></li></ul></li><li><p>Etag / If-None-Match</p><ul><li><p>这两个值是有服务器生成的每个资源的唯一标示字符串，资源有变化这个值就会改变</p></li><li><p>判断过程和 Last-Modified / If-Modified-Since 类似</p></li><li><p>与 Last-Modified 不同是 服务器返回的 304 not modified 响应时，由于 ETag 重新生成过， 响应头(response header) 也会把 ETag 返回，即使这个 ETag 更之前的没有变化</p></li></ul></li></ol><h3 id="既生-last-modified-何生-etag" tabindex="-1">既生 Last-Modified 何生 Etag <a class="header-anchor" href="#既生-last-modified-何生-etag" aria-label="Permalink to &quot;既生 Last-Modified 何生 Etag&quot;">​</a></h3><p>Etag 主要是为了解决几个 last-modified 比较难解决的问题</p><ul><li><p>一些资源也许会周期性的修改，但是他的内容并不改变（仅仅改变的是修改时间），这时候我们并不希望客户端认为这个文件被修改来，而重新 get</p></li><li><p>某些文件修改频繁，比如在秒一下的时间进行修改，（比如 1s 内修改来N次），if-modified-since 能检查到颗粒度是 s(秒)级的， 这种修改无法判断（或者说 UNIX记录MTIME只能精确到秒）</p></li><li><p>某些服务器不能精确到文件的最后修改时间</p></li></ul><p>这时候 利用 Etag 能够更加准确的控制缓存，因为 Etag 是服务器自动生成或者开发者生成，对应资源在服务器端的唯一标示符</p><p>last-modified 和 Etag 可以一起是使用，<strong>服务器会优先验证 ETag</strong>，一致的情况下，才会继续对比 last-modified，最后决定是否返回 304</p><h3 id="用户行为对缓存的影响" tabindex="-1">用户行为对缓存的影响 <a class="header-anchor" href="#用户行为对缓存的影响" aria-label="Permalink to &quot;用户行为对缓存的影响&quot;">​</a></h3><table><thead><tr><th>用户操作</th><th>Expires / Cache-Control</th><th>Last-Modified / Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td>有效</td><td>有效</td></tr><tr><td>页面链接跳转</td><td>有效</td><td>有效</td></tr><tr><td>新开窗口</td><td>有效</td><td>有效</td></tr><tr><td>前进后退</td><td>有效</td><td>有效</td></tr><tr><td>F5 刷新</td><td>有效</td><td>有效</td></tr><tr><td>Ctrl + F5 刷新</td><td>有效</td><td>有效</td></tr></tbody></table><h2 id="http-状态码-todo" tabindex="-1">http 状态码 todo <a class="header-anchor" href="#http-状态码-todo" aria-label="Permalink to &quot;http 状态码 todo&quot;">​</a></h2><ul><li>2XX：成功状态码 <ul><li>200：服务器接收并处理成功</li></ul></li><li>3XX：重定向 <ul><li>301：请求的资源被永久重定向</li><li>304：服务器回应客户端请求，告诉客户端本地缓存可用（协商缓存）</li></ul></li><li>4XX：客户端错误 <ul><li>400：客户端请求语法错误（请求参数错误）</li><li>401：请求未授权，需要认证用户的身份</li><li>403：没有权限访问</li><li>404：访问的资源不存在</li></ul></li><li>5XX：服务端错误 <ul><li>500：服务器内部错误</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503：服务器端暂时无法处理请求（可能是过载或维护）</li></ul></li></ul><h2 id="http、https-区别" tabindex="-1">http、https 区别 <a class="header-anchor" href="#http、https-区别" aria-label="Permalink to &quot;http、https 区别&quot;">​</a></h2><p><a href="https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%B8%89%E3%80%81%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">http、https 区别</a></p><ul><li><p>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</p></li><li><p>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</p></li><li><p>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</p></li><li><p>HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高</p></li><li><p>http：IP =&gt; TCP =&gt; HTTP(应用层)</p></li><li><p>https：IP =&gt; TCP =&gt; SSL =&gt; HTTP(应用层)</p></li></ul><h2 id="https-请求过程-ssl握手-加密过程" tabindex="-1">https 请求过程（ssl握手，加密过程） <a class="header-anchor" href="#https-请求过程-ssl握手-加密过程" aria-label="Permalink to &quot;https 请求过程（ssl握手，加密过程）&quot;">​</a></h2><p><a href="https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%BA%8C%E3%80%81https" target="_blank" rel="noreferrer">https 过程</a></p><ol><li>客户端通过 URL 访问服务器建立 SSL 连接</li><li>服务器返回证书信息，客户端拿到公钥（证书中有公钥）</li><li>客户端和服务器协商 SSL 连接安全等级，也就是信息加密等级</li><li>客户端根据加密等级，建立会话密钥，然后利用获取的公钥对会话密钥进行加密，传送到服务器</li><li>服务器利用自己的私钥解密会话密钥</li><li>通过会话密钥加密进行通信</li></ol><h2 id="https-的缺点" tabindex="-1">https 的缺点 <a class="header-anchor" href="#https-的缺点" aria-label="Permalink to &quot;https 的缺点&quot;">​</a></h2><ul><li>https 协议多次握手，导致页面加载时间过程</li><li>https 链接缓存不如 http 高效，会增加数据开销和功耗</li><li>申请 SSL 证书需要钱，功能越强大证书费用越高</li></ul><h2 id="http-安全" tabindex="-1">http 安全 <a class="header-anchor" href="#http-安全" aria-label="Permalink to &quot;http 安全&quot;">​</a></h2><p><a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noreferrer">参考</a></p><p><a href="https://vue3js.cn/interview/JavaScript/security.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">web常见的攻击方式有哪些？如何防御？</a></p><h3 id="xss-跨站脚本攻击" tabindex="-1">XSS 跨站脚本攻击 <a class="header-anchor" href="#xss-跨站脚本攻击" aria-label="Permalink to &quot;XSS 跨站脚本攻击&quot;">​</a></h3><p>恶意将代码注入到客户端攻击</p><ul><li><p>攻击模式：</p><ul><li>基于 DOM：恶意修改页面的 dom 结构，是纯粹的客户端攻击</li><li>存储型：例如写文章的平台，用户恶意写了一段js代码，保存文章，那么以后打开这篇文章的人都会遭到恶意代码的攻击</li><li>反射型：诱导用户点击恶意连接，用户点击后注入恶意脚本到客户端</li></ul></li><li><p>预防：</p><ul><li>给 cookie 设置 <code>httpOnly</code> ，禁止 js 脚本访问 cookie</li><li>输入检查，不要相信用户输入的内容，对输入的内容进行必要的过滤、转义，例如vue源码里面 decodingMap 对输入内容转换，转义</li><li>输出检查，客户端拿到数据时候，有些渲染也要进行必要过滤、转义，vue 的 v-html，</li></ul></li></ul><h3 id="csrf-跨站请求伪造" tabindex="-1">CSRF 跨站请求伪造 <a class="header-anchor" href="#csrf-跨站请求伪造" aria-label="Permalink to &quot;CSRF 跨站请求伪造&quot;">​</a></h3><p>一种劫持受信任用户向服务器发送非预期请求的方式</p><p>通常情况 CSRF 攻击是借助受害者的 cookie 骗取服务器的信任来进行一些操作</p><ul><li>预防： <ul><li>服务端添加 Referer 判断</li><li>token 验证，服务器生成token，前端请求的时候添加token，服务器校验token 是否正确</li></ul></li></ul><h2 id="浏览器输入后回车的事情" tabindex="-1">浏览器输入后回车的事情 <a class="header-anchor" href="#浏览器输入后回车的事情" aria-label="Permalink to &quot;浏览器输入后回车的事情&quot;">​</a></h2><ul><li>DNS 解析 url 对应的 ip</li><li>根据 ip 建立 TCP 连接（三次握手）</li><li>客户端发送 HTTP 请求</li><li>服务端处理请求，浏览器接受 http 响应</li><li>关闭 tcp 连接（四次挥手）</li><li>浏览器渲染页面，创建渲染树</li></ul><h2 id="渲染页面的过程以及遇到的问题" tabindex="-1">渲染页面的过程以及遇到的问题 <a class="header-anchor" href="#渲染页面的过程以及遇到的问题" aria-label="Permalink to &quot;渲染页面的过程以及遇到的问题&quot;">​</a></h2><p><strong>流程：</strong></p><ol><li>浏览器从上到下解析 html 文档，创建 dom 树</li><li>解析 css 生成 cssom （css 规则树）</li><li>解析完成后，浏览器会根据 dom 树和 css 规则树来构造渲染树（Render Tree）</li><li>根据渲染树的节点，布局到屏幕的正确的位置</li><li>遍历渲染树所有节点，绘制页面</li></ol><p><strong>浏览器在创建 dom 树过程：</strong></p><ul><li><p>遇到 css 的时候：会异步下载，生成异步的 css 规则树，不会堵塞 dom 树的出构建，但是会影响渲染树的最终生成， 因为渲染树有 dom 树和 css 规则树组成</p></li><li><p>遇到 js的时候：dom 树构建会停止，会先去加载和执行 js 代码，会中断构建 dom 树， 如果这时候 js 操作页面样式，还有可能造成，重绘或回流</p></li></ul><p><strong>这时候产生的优化问题：</strong></p><ul><li><p>css 优化：首屏页面 css 独立出来，放到 style 里面 内行加载</p></li><li><p>JS 优化：在页面的最下面引入 js，或者使用 defer 属性，这样页面在渲染会在渲染完成后加载</p><ul><li>async：异步加载，下载过程中不会影响到 html 的解析，但是下载完成后会立即执行，对堵塞 html 解析</li><li>defer：异步加载，下载过程中不会影响到 html 的解析，会在所有的元素解析完成后，DOMContentLoaded 事件之前触发完成</li></ul></li></ul><h2 id="tcp-的三次握手" tabindex="-1">tcp 的三次握手 <a class="header-anchor" href="#tcp-的三次握手" aria-label="Permalink to &quot;tcp 的三次握手&quot;">​</a></h2><p><strong>三次过程：</strong></p><ul><li>客户端：你能收我消息么？</li><li>服务端：可以的，你能接收到我的回复吗？</li><li>客户端：可以的，那我们开始聊正事把</li></ul><ol><li>为啥是3次：</li></ol><ul><li>三次是最少的安全次数，两次不安全，四次浪费资源。</li><li>避免历史链接，确定客户端发的请求是这次通讯的人</li></ul><ol start="2"><li>为啥不是4次：</li></ol><ul><li>四次浪费资源</li></ul><h2 id="tcp-协议-四次挥手" tabindex="-1">tcp 协议 四次挥手 <a class="header-anchor" href="#tcp-协议-四次挥手" aria-label="Permalink to &quot;tcp 协议 四次挥手&quot;">​</a></h2><p>TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道：</p><ul><li>通道1：客户端的输出链接服务端的输入</li><li>通道2：客户端的输入链接服务端的输出</li></ul><p>两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。</p><p>关闭通道：</p><ul><li>客户端：我要关闭通道了</li><li>服务端：好的你关闭，我这边也要关闭通道了</li><li>服务端：我也要关闭通道了</li><li>客户端：好的，你关闭吧，我也吧这个通道关闭了</li></ul><ol><li><p>为什么不能是两次</p><ul><li>无法确认服务端是否能到断开消息，还有服务端可能还有消息未发送完</li></ul></li><li><p>为什么不能是三次</p><ul><li>三次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。</li></ul></li></ol><p><img src="'+a+'" alt="http 握手"></p>',77),d=[r];function p(h,s,n,c,u,T){return i(),l("div",null,d)}const m=t(o,[["render",p]]);export{P as __pageData,m as default};
