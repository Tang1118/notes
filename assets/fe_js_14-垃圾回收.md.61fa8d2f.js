import{_ as e,c as a,o as t,S as l}from"./chunks/framework.9c4db3f7.js";const f=JSON.parse('{"title":"js 垃圾回收","description":"","frontmatter":{},"headers":[],"relativePath":"fe/js/14-垃圾回收.md","filePath":"fe/js/14-垃圾回收.md","lastUpdated":1692682474000}'),r={name:"fe/js/14-垃圾回收.md"},i=l('<h1 id="js-垃圾回收" tabindex="-1">js 垃圾回收 <a class="header-anchor" href="#js-垃圾回收" aria-label="Permalink to &quot;js 垃圾回收&quot;">​</a></h1><ul><li><p><a href="https://mp.weixin.qq.com/s/EWAcPO5CbdoYAm0HQpRl_g" target="_blank" rel="noreferrer">V8垃圾回收</a></p></li><li><p><a href="https://vue3js.cn/interview/JavaScript/memory_leak.html#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" target="_blank" rel="noreferrer">垃圾回收机制</a></p></li></ul><h2 id="v8的垃圾回收机制" tabindex="-1">v8的垃圾回收机制 <a class="header-anchor" href="#v8的垃圾回收机制" aria-label="Permalink to &quot;v8的垃圾回收机制&quot;">​</a></h2><ul><li>首先v8的垃圾回收机制是有上限的，为什么有上限主要还是 js 是单线程的， 一旦开始执行垃圾回收机制，辣么他其他的各种逻辑需要暂停的。可以通过node --max-new-space-size= 2048 xxx.js</li><li>栈内存的话其实就是上下文切换之后，栈顶的空间会被自动回收</li><li>堆内存的话其实会分成两种 一种新生代 - 表示临时分配的内存</li></ul><p>一种老生代 表示常驻内存， 存活的时间长。</p><h2 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h2><ol><li>正在使用的内存</li><li>闲置的内存</li><li>就是v8会将From 的对象检查一篇， 如果存活对象就是按照顺序从头放置，非存活直接回收。然后将 From 和 to 两个角色对调。其实主要为了处理内存碎片，将碎片在内存中顺序排好。</li></ol><h2 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h2><p>如果新生代中的变量经过多次回收依然存在，会放到老生代内存中， 这种叫晋升。发生晋升主要有两种情况：</p><ol><li>经历过一次新生代垃圾回收</li><li>闲置空间内存占用超过25%</li></ol><p>标记清楚：</p><p>遍历所有堆中的对象，打上标记。对代码环境中使用的变量或者强引用的取消标记， 剩下的就删除标记。同样会有内存碎片的问题：整理碎片像一端靠拢。</p><p>引用计数</p>',13),o=[i];function s(n,_,c,p,h,d){return t(),a("div",null,o)}const u=e(r,[["render",s]]);export{f as __pageData,u as default};
